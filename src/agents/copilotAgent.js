/**
 * Copilot CLI Agent
 *
 * Handles telemetry from GitHub's Copilot CLI.
 * Events have the prefix 'copilot_cli.' or 'copilot.' and use 'session.id' for session tracking.
 *
 * Copilot CLI does NOT have native OTEL support. Telemetry is generated by:
 * - A wrapper bridge that captures CLI invocations and emits OTEL spans
 * - Parsing session state files from ~/.copilot/session-state
 * - Capturing /usage command output in interactive mode
 *
 * See COPILOT_TELEMETRY.md for configuration details.
 *
 * Supported events:
 * - copilot_cli.run - CLI invocation (wrapper bridge)
 * - copilot_cli.user_prompt - user prompts
 * - copilot_cli.generation - model response with token counts
 * - copilot_cli.api_error - API errors
 * - copilot_cli.tool_call - tool invocations
 * - copilot_cli.usage - usage statistics from /usage command
 * - copilot_cli.session.start - session start
 * - copilot_cli.session.end - session end
 *
 * Langfuse-compatible attributes are supported:
 * - langfuse.trace.name, langfuse.trace.input, langfuse.trace.output
 * - langfuse.observation.type, langfuse.observation.metadata.*
 * - gen_ai.prompt, gen_ai.completion, gen_ai.usage.*
 */

const BaseAgent = require('./baseAgent')
const {
  createConversationStartEvent,
  createUserPromptEvent,
  createGenerationEvent,
  createApiErrorEvent,
  createToolResultEvent,
  createAgentLifecycleEvent,
} = require('./types')

class CopilotAgent extends BaseAgent {
  static get name() {
    return 'copilot'
  }

  static get eventPrefix() {
    return 'copilot_cli.'
  }

  static get provider() {
    return 'github'
  }

  /**
   * Check if this agent can handle the given event
   * Handles copilot_cli.* and copilot.* events (for flexibility with different bridge implementations)
   */
  static canHandle(eventName) {
    return eventName && (eventName.startsWith('copilot_cli.') || eventName.startsWith('copilot.'))
  }

  /**
   * Extract session ID from attributes
   * Copilot uses 'session.id', 'copilot.session.id', or 'conversation.id'
   */
  static extractSessionId(attrs) {
    return attrs['session.id'] || attrs['copilot.session.id'] || attrs['conversation.id'] || null
  }

  /**
   * Process a log record and return a normalized event
   */
  static processEvent(logRecord, attrs, session) {
    const eventName = logRecord.body?.stringValue
    const timestamp = logRecord.timeUnixNano
      ? new Date(Number(logRecord.timeUnixNano) / 1000000).toISOString()
      : new Date().toISOString()

    const baseMetadata = this.getStandardMetadata(attrs, session)
    baseMetadata.agentType = attrs.agent || attrs['copilot.agent']
    baseMetadata.exitCode = attrs.exit_code
    baseMetadata.premiumRequests = attrs.premium_requests

    // Handle Langfuse-specific attributes from bridge wrapper
    if (attrs['langfuse.trace.name']) {
      baseMetadata.langfuseTraceName = attrs['langfuse.trace.name']
    }
    if (attrs['langfuse.observation.type']) {
      baseMetadata.langfuseObservationType = attrs['langfuse.observation.type']
    }

    switch (eventName) {
      case 'copilot_cli.run':
      case 'copilot.run':
        return this._processRun(attrs, timestamp, session, baseMetadata)

      case 'copilot_cli.user_prompt':
      case 'copilot.user_prompt':
        return this._processUserPrompt(attrs, timestamp, session, baseMetadata)

      case 'copilot_cli.generation':
      case 'copilot.generation':
        return this._processGeneration(attrs, timestamp, session, baseMetadata)

      case 'copilot_cli.api_error':
      case 'copilot.api_error':
        return this._processApiError(attrs, timestamp, session, baseMetadata)

      case 'copilot_cli.tool_call':
      case 'copilot.tool_call':
        return this._processToolCall(attrs, timestamp, session, baseMetadata)

      case 'copilot_cli.usage':
      case 'copilot.usage':
        return this._processUsage(attrs, timestamp, session, baseMetadata)

      case 'copilot_cli.session.start':
      case 'copilot.session.start':
        return this._processSessionStart(attrs, timestamp, session, baseMetadata)

      case 'copilot_cli.session.end':
      case 'copilot.session.end':
        return this._processSessionEnd(attrs, timestamp, session, baseMetadata)

      default:
        // Check for other copilot_cli.* or copilot.* events we might want to log
        if (eventName && (eventName.startsWith('copilot_cli.') || eventName.startsWith('copilot.'))) {
          this.logger.debug({ eventName, agent: this.name }, 'Unknown Copilot CLI event')
        }
        return null
    }
  }

  /**
   * Process CLI run event - emitted by wrapper bridge for each CLI invocation
   * Attributes: prompt, output, duration_s, exit_code, agent, stderr
   *             gen_ai.prompt, gen_ai.completion (Langfuse-compatible)
   *             langfuse.trace.input, langfuse.trace.output (Langfuse-compatible)
   */
  static _processRun(attrs, timestamp, session, baseMetadata) {
    // Support both custom and Langfuse-compatible attribute names
    const prompt = attrs.prompt || attrs['gen_ai.prompt'] || attrs['langfuse.trace.input'] || ''
    const output = attrs.output || attrs['gen_ai.completion'] || attrs['langfuse.trace.output'] || ''
    const durationS = parseFloat(attrs.duration_s || attrs['duration'] || '0')
    const durationMs = Math.round(durationS * 1000)
    const exitCode = parseInt(attrs.exit_code || '0', 10)
    const agent = attrs.agent || 'default'
    const stderr = attrs.stderr

    // Token usage if available (from /usage parsing or model response)
    const inputTokens = parseInt(attrs.input_tokens || attrs['gen_ai.usage.input_tokens'] || '0', 10)
    const outputTokens = parseInt(attrs.output_tokens || attrs['gen_ai.usage.output_tokens'] || '0', 10)
    const cost = parseFloat(attrs.cost_usd || attrs.cost || '0')

    const success = exitCode === 0

    this.logger.info(
      {
        sessionId: session.sessionId,
        agent,
        durationMs,
        exitCode,
        success,
        hasOutput: !!output,
        tokens: inputTokens + outputTokens,
        agentName: this.name,
      },
      'Copilot CLI run processed',
    )

    return createGenerationEvent({
      timestamp,
      sessionId: session.sessionId,
      model: attrs.model || 'copilot',
      durationMs,
      inputTokens,
      outputTokens,
      cost,
      input: prompt,
      output: output ? output.substring(0, 2000) : null, // Truncate long outputs
      metadata: {
        ...baseMetadata,
        agent,
        exitCode,
        success,
        stderr: stderr ? stderr.substring(0, 500) : null,
        source: 'bridge-wrapper',
      },
    })
  }

  /**
   * Process user prompt event
   * Attributes: prompt, prompt_length, agent
   */
  static _processUserPrompt(attrs, timestamp, session, baseMetadata) {
    const prompt = attrs.prompt || attrs['gen_ai.prompt'] || ''
    const promptLength = parseInt(attrs.prompt_length || String(prompt.length) || '0', 10)
    const agent = attrs.agent || 'default'

    this.logger.info(
      {
        sessionId: session.sessionId,
        promptLength,
        agent,
        hasPrompt: !!prompt,
        agentName: this.name,
      },
      'User prompt received',
    )

    return createUserPromptEvent({
      timestamp,
      sessionId: session.sessionId,
      userId: attrs['user.id'] || session.metadata?.userId,
      prompt,
      promptLength,
      metadata: {
        ...baseMetadata,
        agent,
      },
    })
  }

  /**
   * Process generation event - model response with token counts
   * Attributes: model, duration_ms, input_tokens, output_tokens, cost_usd,
   *             response_text, finish_reason
   */
  static _processGeneration(attrs, timestamp, session, baseMetadata) {
    const model = attrs.model || 'copilot'
    const durationMs = parseInt(attrs.duration_ms || '0', 10)
    const inputTokens = parseInt(attrs.input_tokens || attrs['gen_ai.usage.input_tokens'] || '0', 10)
    const outputTokens = parseInt(attrs.output_tokens || attrs['gen_ai.usage.output_tokens'] || '0', 10)
    const cost = parseFloat(attrs.cost_usd || attrs.cost || '0')
    const output = attrs.response_text || attrs['gen_ai.completion'] || ''
    const finishReason = attrs.finish_reason

    this.logger.info(
      {
        sessionId: session.sessionId,
        model,
        durationMs,
        tokens: inputTokens + outputTokens,
        cost,
        agentName: this.name,
      },
      'Generation processed',
    )

    return createGenerationEvent({
      timestamp,
      sessionId: session.sessionId,
      model,
      durationMs,
      inputTokens,
      outputTokens,
      cost,
      output: output ? output.substring(0, 2000) : null,
      metadata: {
        ...baseMetadata,
        finishReason,
      },
    })
  }

  /**
   * Process API error event
   * Attributes: error, error_type, status_code, duration_ms
   */
  static _processApiError(attrs, timestamp, session, baseMetadata) {
    const errorMessage = attrs.error || attrs.error_message || 'Unknown error'
    const errorType = attrs.error_type || 'unknown'
    const statusCode = parseInt(attrs.status_code || '0', 10)
    const durationMs = parseInt(attrs.duration_ms || '0', 10)
    const model = attrs.model || 'copilot'

    this.logger.warn(
      {
        sessionId: session.sessionId,
        error: errorMessage,
        errorType,
        statusCode,
        model,
        agentName: this.name,
      },
      'API error occurred',
    )

    return createApiErrorEvent({
      timestamp,
      sessionId: session.sessionId,
      model,
      errorMessage,
      statusCode,
      durationMs,
      metadata: {
        ...baseMetadata,
        errorType,
      },
    })
  }

  /**
   * Process tool call event
   * Attributes: tool_name, tool_args, duration_ms, success, error
   */
  static _processToolCall(attrs, timestamp, session, baseMetadata) {
    const toolName = attrs.tool_name || attrs.function_name || 'unknown'
    const success = attrs.success === 'true' || attrs.success === true
    const durationMs = parseInt(attrs.duration_ms || '0', 10)
    const error = attrs.error

    // Parse tool arguments
    let toolArgs = null
    if (attrs.tool_args || attrs.function_args) {
      try {
        const argsStr = attrs.tool_args || attrs.function_args
        toolArgs = typeof argsStr === 'string' ? JSON.parse(argsStr) : argsStr
      } catch {
        toolArgs = attrs.tool_args || attrs.function_args
      }
    }

    this.logger.info(
      {
        sessionId: session.sessionId,
        tool: toolName,
        success,
        durationMs,
        agentName: this.name,
      },
      'Tool call processed',
    )

    return createToolResultEvent({
      timestamp,
      sessionId: session.sessionId,
      toolName,
      success,
      durationMs,
      arguments: toolArgs,
      error,
      metadata: baseMetadata,
    })
  }

  /**
   * Process usage event - from /usage command or session stats
   * Attributes: premium_requests, session_duration_s, lines_edited, token_breakdown
   */
  static _processUsage(attrs, timestamp, session, baseMetadata) {
    const premiumRequests = parseInt(attrs.premium_requests || '0', 10)
    const sessionDurationS = parseFloat(attrs.session_duration_s || '0')
    const sessionDurationMs = Math.round(sessionDurationS * 1000)
    const linesEdited = parseInt(attrs.lines_edited || '0', 10)

    // Parse token breakdown if available (JSON string)
    let tokenBreakdown = null
    if (attrs.token_breakdown) {
      try {
        tokenBreakdown =
          typeof attrs.token_breakdown === 'string'
            ? JSON.parse(attrs.token_breakdown)
            : attrs.token_breakdown
      } catch {
        tokenBreakdown = attrs.token_breakdown
      }
    }

    this.logger.info(
      {
        sessionId: session.sessionId,
        premiumRequests,
        sessionDurationMs,
        linesEdited,
        agentName: this.name,
      },
      'Usage stats processed',
    )

    // Return as a generation event to capture usage metrics
    return createGenerationEvent({
      timestamp,
      sessionId: session.sessionId,
      model: 'copilot',
      durationMs: sessionDurationMs,
      inputTokens: tokenBreakdown?.input || 0,
      outputTokens: tokenBreakdown?.output || 0,
      metadata: {
        ...baseMetadata,
        premiumRequests,
        linesEdited,
        tokenBreakdown,
        source: 'usage-command',
      },
    })
  }

  /**
   * Process session start event
   * Attributes: agent, model, config
   */
  static _processSessionStart(attrs, timestamp, session, baseMetadata) {
    const agent = attrs.agent || 'default'
    const model = attrs.model || 'copilot'

    this.logger.info(
      {
        sessionId: session.sessionId,
        agent,
        model,
        agentName: this.name,
      },
      'Session started',
    )

    return createConversationStartEvent({
      timestamp,
      sessionId: session.sessionId,
      userId: attrs['user.id'] || session.metadata?.userId,
      provider: this.provider,
      model,
      extraConfig: {
        agent,
      },
      metadata: baseMetadata,
    })
  }

  /**
   * Process session end event
   * Attributes: agent, duration_ms, premium_requests, termination_reason
   */
  static _processSessionEnd(attrs, timestamp, session, baseMetadata) {
    const agent = attrs.agent || 'default'
    const durationMs = parseInt(attrs.duration_ms || '0', 10)
    const premiumRequests = parseInt(attrs.premium_requests || '0', 10)
    const terminationReason = attrs.termination_reason || 'completed'

    this.logger.info(
      {
        sessionId: session.sessionId,
        agent,
        durationMs,
        premiumRequests,
        terminationReason,
        agentName: this.name,
      },
      'Session ended',
    )

    return createAgentLifecycleEvent({
      timestamp,
      sessionId: session.sessionId,
      agentName: agent,
      lifecycle: 'finish',
      durationMs,
      terminationReason,
      metadata: {
        ...baseMetadata,
        premiumRequests,
      },
    })
  }
}

module.exports = CopilotAgent
